[tool.ruff]
target-version = "py311"
line-length = 88
# Enable unsafe fixes for maximum automation
unsafe-fixes = true

[tool.ruff.lint]
select = [
  "A",     # flake8-builtins (shadowing builtins)
  "ASYNC", # flake8-async (async/await best practices)
  "ANN",   # flake8-annotations (type annotations)
  "ARG",   # flake8-unused-arguments (unused arguments)
  "B",     # flake8-bugbear (common bugs)
  "BLE",   # flake8-blind-except (blind except)
  "C",     # flake8-comprehensions (list/dict/set comprehensions)
  "COM",   # flake8-commas (trailing commas)
  "D",     # pydocstyle (docstring checks)
  "DTZ",   # flake8-datetimez (datetimez)
  "E",     # pycodestyle errors (replaces flake8 E codes)
  "EM",    # flake8-errmsg (error message formatting)
  "ERA",   # eradicate (commented-out code)
  "F",     # Pyflakes (replaces flake8 F codes)
  "FA",    # flake8-future-annotations (future annotations)
  "FBT",   # flake8-boolean-trap (boolean trap)
  "FLY",   # flynt (f-string conversions)
  "FURB",  # refurb (modernize Python code)
  "G",     # flake8-logging-format (logging format)
  "I",     # isort (import sorting)
  "ICN",   # flake8-import-conventions (import conventions)
  "INP",   # flake8-no-pep420 (module imports)
  "LOG",   # flake8-logging (logging best practices)
  "N",     # pep8-naming (naming conventions)
  "PERF",  # Perflint (performance anti-patterns)
  "PIE",   # flake8-pie (pie)
  "PLC",   # Pylint Convention rules
  "PLE",   # Pylint Error rules
  "PLR",   # Pylint Refactor rules
  "PLW",   # Pylint Warning rules
  "PT",    # flake8-pytest-style (pytest style)
  "PTH",   # flake8-use-pathlib (pathlib usage)
  "PYI",   # flake8-pyi (type annotations)
  "Q",     # flake8-quotes (quotes)
  "RET",   # flake8-return (return statement checks)
  "RSE",   # flake8-raise (raise Exception)
  "RUF",   # Ruff-specific rules
  "S",     # flake8-bandit (security)
  "T",     # flake8-print (print statements)
  "SIM",   # flake8-simplify (code simplification)
  "SLF",   # flake8-self (private member access)
  "TCH",   # flake8-type-checking (type checking imports)
  "TID",   # flake8-tidy-imports (import conventions)
  "TRY",   # tryceratops (try-except-cleanup)
  "UP",    # pyupgrade (Python version upgrade syntax)
  "W",     # pycodestyle warnings (replaces flake8 W codes)
]

ignore = [
  "A002",   # builtin-argument-shadowing (for 'id' parameter)
  "ANN401", # missing-type-parameters (missing type parameters)
  "D105",   # missing-magic-method-docstring
  "FIX002", # line-contains-todo
]

[tool.ruff.lint.pydocstyle]
convention = "google"

[tool.ruff.lint.per-file-ignores]
"tests/*" = [
  "A001",    # builtin shadowing allowed in tests (id)
  "B007",    # unused-loop-control-variable allowed in tests
  "B017",    # pytest.raises(Exception) allowed in tests
  "D",       # docstrings not required in tests
  "PLR0124", # comparison-with-itself allowed for equality tests
  "PLR0914", # too-many-locals allowed in tests (was max-locals=15)
  "PLR0915", # too-many-statements allowed in tests (was max-statements=30)
  "PLR0911", # too-many-return-statements
  "PLR0912", # too-many-branches
  "PLR0913", # too-many-arguments allowed in test helpers and fixtures
  "PLR2004", # magic values allowed in tests
  "RUF001",  # ambiguous-unicode-character allowed in tests
  "S101",    # assert-used (needed in tests)
  "S608",    # SQL injection not a concern in test fixtures
  "SIM103",  # return-in-try-except-finally allowed in tests
  "SIM117",  # nested-with allowed in tests
  "S108",    # hardcoded-temp-file allowed in tests
  "TRY301",  # abstract-raise-to-inner-function allowed in tests
]

"scripts/test_all.py" = [
  "S603", # subprocess calls are intentional in this controlled script
]

[tool.pytest.ini_options]
python_files = "test_*.py"
python_classes = "Test*"
python_functions = "test_*"

# Output and behavior
addopts = [
  "-v",                        # verbose
  "--tb=short",                # shorter tracebacks
  "--strict-markers",          # ensure all markers are registered
  "--cov=.",                   # coverage for entire project root
  "--cov-report=term-missing", # show missing lines in terminal
  "--cov-report=html:htmlcov", # generate HTML coverage report
  "--cov-fail-under=100",      # fail if coverage below 100%
  "-n=auto",                   # run tests in parallel using all available CPU cores
  "--maxfail=5",               # stop after 5 failures to fail fast
]

# Performance optimizations
cache_dir = ".pytest_cache"

# Filter warnings
filterwarnings = [
  "ignore:.*PyType_Spec.*tp_new.*deprecated.*:DeprecationWarning",
]

# Test markers
markers = [
  "slow: marks tests as slow (deselect with '-m \"not slow\"')",
  "integration: marks tests that interact with database",
  "unit: marks pure unit tests with no dependencies",
]

[tool.coverage.run]
source = ["."] # Use project root for coverage
omit = [
  "*/tests/*",
  "*/test_*.py",
  "*/.venv/*",
  "*/venv/*",
  "conftest.py",
  "*/site-packages/*",
  "*/dist-packages/*",
  "*.pxd",
]

[tool.coverage.report]
exclude_lines = [
  "pragma: no cover",
  "def __repr__",
  "if self.debug:",
  "if settings.DEBUG",
  "raise AssertionError",
  "raise NotImplementedError",
  "if 0:",
  "if __name__ == .__main__.:",
  "class .*\\bProtocol\\):",
  "@(abc\\.)?abstractmethod",
  ".*pass.*",
  "if TYPE_CHECKING:",
]

[tool.pyright]
include = ["src", "tests", "dependency_injection"]
exclude = ["**/node_modules", "**/__pycache__"]

# Use strict mode everywhere
typeCheckingMode = "strict"

# Set python path to include project root for import resolution
pythonPath = ["."]

# Strict type checking options
reportUnknownParameterType = true
reportUnknownArgumentType = true
reportUnknownLambdaType = true
reportUnknownVariableType = true
reportUnknownMemberType = true
reportMissingParameterType = true
reportUnnecessaryTypeIgnoreComment = true
reportUnusedCallResult = true
reportUnnecessaryCast = true
reportAssertAlwaysTrue = true
reportSelfClsParameterName = true
reportImplicitStringConcatenation = true

[tool.importlinter]
root_package = "src"
include_external_packages = true

# ===== CORE ARCHITECTURE CONTRACTS =====

# Contract 1: Domain layer must be completely independent
[[tool.importlinter.contracts]]
name = "Domain layer independence"
type = "independence"
modules = ["src.domain"]

# Contract 2: Enforce layered architecture dependencies
[[tool.importlinter.contracts]]
name = "Layered architecture"
type = "layers"
layers = [
  "src.presentation",
  "src.infrastructure",
  "src.application",
  "src.domain",
]

# Contract 3: Application layer should not depend on infrastructure
[[tool.importlinter.contracts]]
name = "Application layer independence from infrastructure"
type = "forbidden"
source_modules = ["src.application"]
forbidden_modules = ["src.infrastructure"]

# Contract 4: Application layer should not depend on presentation
[[tool.importlinter.contracts]]
name = "Application layer independence from presentation"
type = "forbidden"
source_modules = ["src.application"]
forbidden_modules = ["src.presentation"]

# ===== DOMAIN PURITY CONTRACTS =====

# Contract 5: Domain should not use external libraries directly
[[tool.importlinter.contracts]]
name = "Domain purity - no framework dependencies"
type = "forbidden"
source_modules = ["src.domain"]
forbidden_modules = [
  "sqlalchemy",
  "fastapi",
  "pydantic",
  "pytest",
  "httpx",
  "requests",
  "alembic",
  "redis",
  "celery",
  "django",
  "flask",
  "boto3",
  "psycopg2",
  "pymongo",
  "elasticsearch",
  "kafka",
  "rabbitmq",
  "grpc",
  "graphql",
  "dependency_injection",
]

# ===== APPLICATION LAYER CONTRACTS =====

# Contract 6: Application must not import concrete repositories from infrastructure
[[tool.importlinter.contracts]]
name = "Application uses repository interfaces only"
type = "forbidden"
source_modules = ["src.application"]
forbidden_modules = ["src.infrastructure.repositories"]
# Application should depend on domain interfaces, not infrastructure implementations

# ===== PRESENTATION LAYER CONTRACTS =====

# Contract 7: Presentation must not import repositories directly
[[tool.importlinter.contracts]]
name = "Presentation must not use repositories directly"
type = "forbidden"
source_modules = ["src.presentation"]
forbidden_modules = [
  "src.domain.repositories",
  "src.infrastructure.repositories",
]
# Presentation should only use application services, not repositories

# ===== DOMAIN INTERNAL STRUCTURE CONTRACTS =====

# Contract 8: Value objects must be independent (foundation layer)
[[tool.importlinter.contracts]]
name = "Value objects independence"
type = "forbidden"
source_modules = ["src.domain.value_objects"]
forbidden_modules = [
  "src.domain.entities",
  "src.domain.services",
  "src.domain.repositories",
]

# Contract 9: Entities can only depend on value objects
[[tool.importlinter.contracts]]
name = "Entities only use value objects"
type = "forbidden"
source_modules = ["src.domain.entities"]
forbidden_modules = ["src.domain.services", "src.domain.repositories"]
# Entities can use value objects, but not services or repositories

# Contract 10: Services should not have circular dependencies with each other
[[tool.importlinter.contracts]]
name = "No circular dependencies between domain services"
type = "independence"
modules = [
  "src.domain.services.portfolio_calculation_service",
  "src.domain.services.risk_assessment_service",
]
# List specific service modules to prevent circular deps between services

# Contract 11: Repository interfaces should not depend on services
[[tool.importlinter.contracts]]
name = "Repository interfaces independence"
type = "forbidden"
source_modules = ["src.domain.repositories"]
forbidden_modules = ["src.domain.services"]
# Repository interfaces can use entities and value objects, but not services

# Contract 12: Entities should not depend on services
[[tool.importlinter.contracts]]
name = "Entity independence from services"
type = "forbidden"
source_modules = ["src.domain.entities"]
forbidden_modules = ["src.domain.services"]

# ===== TEST ORGANIZATION CONTRACTS =====

# Contract 13: Source code should not import from tests
[[tool.importlinter.contracts]]
name = "Source code independence from tests"
type = "forbidden"
source_modules = ["src"]
forbidden_modules = ["tests", "fixtures"]

# Contract 14: Domain tests should use only domain code
# Note: This contract is documented but cannot be enforced since tests
# are outside the root_package scope. Consider manual review during PR.


